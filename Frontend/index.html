<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Start Vision Test</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: rgb(59, 220, 248);
      padding: 2rem;
      text-align: center;
    }
    .notice {
      font-size: 1.3rem;
      margin-bottom: 2rem;
    }
    .status {
      font-size: 1.2rem;
      font-weight: bold;
      color: #004080;
    }
    button {
      padding: 1rem 2rem;
      background: #042c54;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      margin: 0.5rem;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .debug {
      font-size: 0.9rem;
      color: #333;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <h1>Start Your Vision Test üëÅÔ∏è</h1>
  <p class="notice">
    Hold your phone steady and walk back approximately <strong>10 feet (3 meters)</strong> in a straight line.<br>
    We'll alert you when you're ready.
  </p>

  <p class="status" id="status">Waiting for device permission...</p>
  <button onclick="requestMotionPermission()">Start</button>
  <button onclick="stopTracking()" id="cancelButton" style="display: none;">Cancel</button>
  <button onclick="forceStep()" id="forceStepButton" style="display: none;">Force Step (Debug)</button>
  <p class="debug" id="debug">Debug: Waiting...</p>

  <script>
    let totalDistance = 0;
    let stepCount = 0;
    let lastTimestamp = null;
    let tracking = false;
    let gravity = { x: 0, y: 0, z: 0 };
    let lastAccMagnitude = 0;
    let lastStepTime = 0;
    let isAboveThreshold = false;
    const TARGET_DISTANCE = 3.0; // 3 meters
    const STEP_THRESHOLD = 0.3; // Lowered threshold for step detection
    const STEP_MIN_INTERVAL = 200; // Min time between steps (ms)
    const AVERAGE_STEP_LENGTH = 0.7; // Step length in meters
    const LOW_PASS_ALPHA = 0.6; // Less aggressive filter

    function requestMotionPermission() {
      const status = document.getElementById("status");
      const debug = document.getElementById("debug");
      const startButton = document.querySelector("button[onclick='requestMotionPermission()']");
      const cancelButton = document.getElementById("cancelButton");
      const forceStepButton = document.getElementById("forceStepButton");

      if (!window.isSecureContext) {
        status.textContent = "‚ö†Ô∏è This feature requires a secure connection (HTTPS).";
        return;
      }

      if (typeof DeviceMotionEvent === 'undefined') {
        status.textContent = "‚ö†Ô∏è Device motion not supported on this device.";
        return;
      }

      startButton.disabled = true;

      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              status.textContent = "‚úÖ Motion permission granted. Calibrating...";
              debug.textContent = "Debug: Calibrating gravity...";
              calibrateGravity().then(() => {
                status.textContent = "‚úÖ Calibration done. Tracking...";
                cancelButton.style.display = "inline-block";
                forceStepButton.style.display = "inline-block";
                startTracking();
              });
            } else {
              status.textContent = "‚ùå Motion permission denied. Please enable it in settings or try again.";
              startButton.textContent = "Retry";
            }
          })
          .catch(err => {
            console.error(err);
            status.textContent = "‚ö†Ô∏è Error requesting motion permission.";
          })
          .finally(() => {
            startButton.disabled = false;
          });
      } else {
        status.textContent = "‚úÖ Calibrating...";
        debug.textContent = "Debug: Calibrating gravity...";
        calibrateGravity().then(() => {
          status.textContent = "‚úÖ Calibration done. Tracking...";
          cancelButton.style.display = "inline-block";
          forceStepButton.style.display = "inline-block";
          startTracking();
        });
        startButton.disabled = false;
      }
    }

    function calibrateGravity() {
      return new Promise(resolve => {
        let samples = 0;
        let tempGravity = { x: 0, y: 0, z: 0 };
        const calibrationHandler = event => {
          const acc = event.accelerationIncludingGravity;
          if (acc && acc.x !== null && acc.y !== null && acc.z !== null) {
            tempGravity.x += acc.x;
            tempGravity.y += acc.y;
            tempGravity.z += acc.z;
            samples++;
            if (samples >= 50) {
              gravity.x = tempGravity.x / samples;
              gravity.y = tempGravity.y / samples;
              gravity.z = tempGravity.z / samples;
              console.log("Gravity calibrated:", gravity);
              window.removeEventListener("devicemotion", calibrationHandler);
              resolve();
            }
          }
        };
        window.addEventListener("devicemotion", calibrationHandler);
      });
    }

    function startTracking() {
      totalDistance = 0;
      stepCount = 0;
      lastTimestamp = null;
      lastAccMagnitude = 0;
      lastStepTime = 0;
      isAboveThreshold = false;
      tracking = true;
      window.addEventListener("devicemotion", handleMotion, true);
    }

    function handleMotion(event) {
      if (!tracking) return;

      const status = document.getElementById("status");
      const debug = document.getElementById("debug");
      const acc = event.accelerationIncludingGravity;
      const timestamp = event.timeStamp;

      if (!acc || acc.x === null || acc.y === null || acc.z === null) {
        status.textContent = "‚ö†Ô∏è No valid motion data available.";
        stopTracking();
        return;
      }

      // Remove gravity
      const linearAcc = {
        x: acc.x - gravity.x,
        y: acc.y - gravity.y,
        z: acc.z - gravity.z,
      };

      // Calculate acceleration magnitude
      let accMagnitude = Math.sqrt(
        linearAcc.x * linearAcc.x +
        linearAcc.y * linearAcc.y +
        linearAcc.z * linearAcc.z
      );

      // Apply low-pass filter
      if (lastAccMagnitude !== 0) {
        accMagnitude = LOW_PASS_ALPHA * accMagnitude + (1 - LOW_PASS_ALPHA) * lastAccMagnitude;
      }

      // Step detection: Detect transition from above to below threshold
      if (accMagnitude > STEP_THRESHOLD && !isAboveThreshold && timestamp - lastStepTime > STEP_MIN_INTERVAL) {
        isAboveThreshold = true;
      } else if (accMagnitude < STEP_THRESHOLD && isAboveThreshold) {
        stepCount++;
        totalDistance = stepCount * AVERAGE_STEP_LENGTH;
        lastStepTime = timestamp;
        isAboveThreshold = false;
        console.log(`Step detected: ${stepCount}, Distance: ${totalDistance.toFixed(2)} m, Magnitude: ${accMagnitude.toFixed(2)}`);
      }

      // Update debug info
      debug.textContent = `Debug: Steps: ${stepCount}, Raw Acc: ${Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z).toFixed(2)} m/s¬≤, Filtered: ${accMagnitude.toFixed(2)} m/s¬≤, Threshold: ${STEP_THRESHOLD.toFixed(2)}`;

      // Update last values
      lastAccMagnitude = accMagnitude;
      lastTimestamp = timestamp;

      // Check if target distance is reached
      if (totalDistance >= TARGET_DISTANCE) {
        tracking = false;
        status.textContent = "‚úÖ Distance reached! Starting test...";
        debug.textContent = "Debug: Test complete.";

        if (navigator.vibrate) {
          try {
            navigator.vibrate(500);
          } catch (err) {
            console.warn("Vibration not allowed or failed.");
          }
        }

        setTimeout(() => {
          window.location.href = "/vision_test";
        }, 1500);
      } else {
        status.textContent = `Tracking... Distance: ${totalDistance.toFixed(2)} m (${stepCount} steps)`;
      }
    }

    function forceStep() {
      stepCount++;
      totalDistance = stepCount * AVERAGE_STEP_LENGTH;
      console.log(`Forced step: ${stepCount}, Distance: ${totalDistance.toFixed(2)} m`);
      document.getElementById("status").textContent = `Tracking... Distance: ${totalDistance.toFixed(2)} m (${stepCount} steps)`;
      if (totalDistance >= TARGET_DISTANCE) {
        handleMotion({ timeStamp: Date.now() }); // Trigger completion check
      }
    }

    function stopTracking() {
      tracking = false;
      window.removeEventListener("devicemotion", handleMotion);
      const status = document.getElementById("status");
      const debug = document.getElementById("debug");
      const cancelButton = document.getElementById("cancelButton");
      const forceStepButton = document.getElementById("forceStepButton");
      status.textContent = "Tracking stopped.";
      debug.textContent = "Debug: Tracking stopped.";
      cancelButton.style.display = "none";
      forceStepButton.style.display = "none";
    }
  </script>
</body>
</html>